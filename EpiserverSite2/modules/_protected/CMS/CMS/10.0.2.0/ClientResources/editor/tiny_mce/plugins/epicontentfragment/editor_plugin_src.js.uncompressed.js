(function (tinymce, $) {
    tinymce.create('tinymce.plugins.epicontentfragment', {
        /**
        * Initializes the content fragment non editable support
        *
        * @param {tinymce.Editor} ed Editor instance that the plugin is initialized in.
        * @param {string} url Absolute URL to where the plugin is located.
        */
        init: function (ed, url) {
            // Initializes the content fragment non editable support
            var self = this;
            if (typeof epiContentBlockUtilities == "undefined") {
                var scriptUrl = tinymce.baseURI.toAbsolute("plugins/epipersonalizedcontent/epicontentblockutilities.js");
                tinymce.ScriptLoader.load(scriptUrl, function () {
                    this._init(ed, url);
                }, this);

                tinymce.ScriptLoader.loadQueue();
            }
            else {
                this._init(ed, url);
            }

            ed.onPreInit.addToTop(function () {
                var mceNonEditableClass = tinymce.trim(ed.getParam("noneditable_noneditable_class", "mceNonEditable"));

                // Remove contenteditable attribute generated by DynamicFragmentFactory and add mceNonEditable class.
                ed.parser.addAttributeFilter('class', function (nodes) {
                    var i = nodes.length, className, node;

                    while (i--) {
                        self._convertContentFragmentToNonEditable(nodes[i], mceNonEditableClass);
                    }
                });
            });

            // Flagging that onInit has been executed since _init is executed async and can be called after the editors onInit has been raised.
            ed.onInit.add(function (ed, controlManager) {
                self._onInitCalled = true;
            });
        },

        /**
        * The real initialization triggered by a callback. Adds command and event handlers.
        *
        * @param {tinymce.Editor} ed Editor instance that the plugin is initialized in.
        * @param {string} url Absolute URL to where the plugin is located.
        */
        _init: function (ed, url) {
            // We extend this plug.in with methods that are common for both personalized content, dynamic content and content fragment
            // (defined in epicontentblockutilities.js).
            $.extend(this, epiContentBlockUtilities);
            var self = this;
            self.ed = ed;
            self._contentFragmentClass = ed.getParam("epicontentfragment_cssclass", "epi-contentfragment");
            self._enabledControls = ed.getParam("epicontentfragment_enabledcontrols", "");
            self._controlsDisabled = false;

            var pluginInit = function (ed) {

                ed.onNodeChange.add(function (ed, cm, node, collapsed, options) {
                    // Disable controls not specified in the enabledControls list, using a timeout to
                    // have it happen "lastish" in the event chain
                    setTimeout(function () {
                        if (!ed.destroyed && ed.dom.hasClass(ed.selection.getNode(), self._contentFragmentClass)) {
                                self._setDisabled(true, self._enabledControls);
                                self._controlsDisabled = true;
                            }
                        }, 0);
                });

                ed.onNodeChange.addToTop(function (ed, cm, node) {
                    // Restore disabled controls early to give them a chance to update their state later in the event chain
                    if (self._controlsDisabled && !ed.dom.hasClass(node, self._contentFragmentClass)) {
                        self._setDisabled(false, self._enabledControls);
                        self._controlsDisabled = false;
                    }
                });

                //--------------------------------------------------
                // Prevent insert any kind of fragment inside CF (ContentFragment) through "mceInsertContent" command
                //--------------------------------------------------
                ed.onBeforeExecCommand.add(function (ed, cmd, ui, value, args) {
                    if (cmd === "mceInsertContent" && self._isSelectionContainsCF()) {
                        args.terminate = true;
                    }
                });
            };

            // If the editors onInit event has already been raised, just run the method. Otherwise attach.
            if (self._onInitCalled) {
                pluginInit(ed);
            } else {
                ed.onInit.add(pluginInit);
            }
        },

        /**
        * Check if selection contains any contentfragment block
        */
        _isSelectionContainsCF: function () {
            return this.ed.dom.hasClass(this.ed.selection.getNode(), this._contentFragmentClass);
        },

        _convertContentFragmentToNonEditable: function (node, mceNonEditableClass) {
            var nodeClass = node.attr("class") + " ";

            if (nodeClass.indexOf("epi-contentfragment") === -1 || nodeClass.indexOf(mceNonEditableClass) >= 0) {
                return;
            }

            // remove contenteditable attribute
            node.attr("contenteditable", null);

            //add mceNoneditable class
            node.attr("class", nodeClass + mceNonEditableClass);
        },

        /**
        * Returns information about the plugin as a name/value array.
        *
        * @return {Object} Name/value array containing information about the plugin.
        */
        getInfo: function () {
            return {
                longname: 'Content Fragment',
                author: 'EPiServer AB',
                authorurl: 'http://www.episerver.com',
                infourl: 'http://www.episerver.com',
                version: "1.0"
            };
        }
    });

    // Register plugin
    tinymce.PluginManager.add('epicontentfragment', tinymce.plugins.epicontentfragment);
}(tinymce, epiJQuery));
