(function (tinymce, $) {
    var Event = tinymce.dom.Event;
    tinymce.PluginManager.requireLangPack('epidynamiccontent');

    tinymce.create('tinymce.plugins.epidynamiccontent', {
        _onInitCalled: false, // A flag to signal if the editors onInit event has occured

        /**
        * Initializes of epidynamiccontentPlugin. Adds command, button and nodeChange event handler.
        *
        * @param {tinymce.Editor} ed Editor instance that the plugin is initialized in.
        * @param {string} url Absolute URL to where the plugin is located.
        */
        init: function (ed, url) {
            var self = this;
            // Early exit if we don't have access to EPi...
            if (typeof EPi === "undefined" || typeof EPi.ResolveUrlFromUI != "function") {
                return;
            }

            if (typeof epiContentBlockUtilities == "undefined") {
                var scriptUrl = tinymce.baseURI.toAbsolute("plugins/epipersonalizedcontent/epicontentblockutilities.js");
                tinymce.ScriptLoader.load(scriptUrl, function () {
                    this._init(ed, url);
                }, this);

                tinymce.ScriptLoader.loadQueue();
            }
            else {
                this._init(ed, url);
            }

            ed.addButton('epidynamiccontent', {
                title: 'epidynamiccontent.desc',
                cmd: 'mceEPiDynamicContent'
            });

            // Flagging that onInit has been executed since _init is executed async and can be called after the editors onInit has been raised.
            ed.onInit.add(function () {
                self._onInitCalled = true;
            });

            ed.onPreInit.addToTop(function () {
                var mceNonEditableClass = tinymce.trim(ed.getParam("noneditable_noneditable_class", "mceNonEditable"));

                // Remove contenteditable attribute generated by DynamicFragmentFactory and add mceNonEditable class.
                ed.parser.addAttributeFilter('class', function (nodes) {
                    var i = nodes.length, className, node;

                    while (i--) {
                        self._convertDCToMceNonEditable(nodes[i], mceNonEditableClass);
                    }
                });
            });
        },

        /**
        * The real initialization triggered by a callback. Adds command and event handlers.
        *
        * @param {tinymce.Editor} ed Editor instance that the plugin is initialized in.
        * @param {string} url Absolute URL to where the plugin is located.
        */
        _init: function (ed, url) {
            //We extend this plug.in with methods that are common for both personalized content and dynamic content (defined in personalizedblock.js).
            $.extend(this, epiContentBlockUtilities);
            var self = this;

            self._url = url;
            self.ed = ed;
            self._disabled = false; // Initially no controls are disabled.
            self._dynamicContentClass = ed.getParam("epidynamiccontent_cssclass", "epi_dc");
            self._enabledControls = ed.getParam("epidynamiccontent_enabledcontrols", "");

            ed.addCommand('mceEPiDynamicContent', function () {
                // Resolve the path to the dynamic content dialog and append the page context parameters to the query string.
                var ctx = $.extend({}, ed.settings.epi_page_context);
                $(document).trigger("epi.loading.page_context", ctx)
                var dialogURL = EPi.ResolveUrlFromUI('Editor/Dialogs/DynamicContent.aspx') + "?" + $.param(ctx);
                var selectedNode = null;

                var onDialogComplete = function (returnData, onComleteArgs) {
                    // Called to insert dynamic content when the dialog is closed.
                    var selection = ed.selection;

                    if (!returnData) {
                        ed.windowManager.onClose.dispatch();
                        return;
                    }

                    if (selectedNode) {
                        selection.select(selectedNode);
                    }

                    ed.execCommand("mceInsertRawHTML", false, returnData);

                    self._onContentChanged();
                    ed.windowManager.onClose.dispatch();
                };

                var selection = ed.selection; // Get the selection from the editor.
                selectedNode = self._getParentContentBlock(selection.getStart());

                var dialogFeatures = { width: 600, height: 640 };

                var allContentGroups = self._getAllContentGroups(ed);

                if (selectedNode) {
                    // Inject a form into the opened dialog to be able to post the dynamic content data to the aspx.
                    var systemCSS = EPi.ResolveUrlFromUtil("../App_Themes/Default/Styles/system.css");

                    var groupAttribute = selectedNode.getAttribute("data-groups");
                    var groupValue = groupAttribute ? groupAttribute.replace(/"/g, '&quot;') : "";

                    var contentgroupAttribute = selectedNode.getAttribute("data-contentgroup");
                    var contentgroupValue = contentgroupAttribute ? contentgroupAttribute.replace(/"/g, '&quot;') : "";

                    var formString = '<html xmlns="http://www.w3.org/1999/xhtml"><head><link href="' + systemCSS + '" type="text/css" rel="stylesheet" /><title></title></head><body>' +
                    '<form action="' + dialogURL + '" method="post">' +
                    '<input name="state" type="hidden" value="' + selectedNode.getAttribute("data-state").replace(/"/g, '&quot;') + '" />' +
                    '<input name="hash" type="hidden" value="' + selectedNode.getAttribute("data-hash").replace(/"/g, '&quot;') + '" />' +
                    '<input name="dynamicclass" type="hidden" value="' + selectedNode.getAttribute("data-dynamicclass").replace(/"/g, '&quot;') + '" />' +
                    '<input name="groups" type="hidden" value="' + groupValue + '" />' +
                    '<input name="contentgroup" type="hidden" value="' + contentgroupValue + '" />' +
                    '<input name="allcontentgroups" type="hidden" value="' + allContentGroups + '" />' +
                    '</form></body></html>';

                    var onOpenLegacyDialog = function (epiLegacyDialog) {
                        if (epiLegacyDialog) {
                            var wrapper = epiLegacyDialog.wrapper;
                            var content = wrapper.containerIframe.contentWindow;
                            content.document.write(formString);
                            content.document.close();
                            content.document.forms[0].submit();
                        }
                    }

                    ed.windowManager.open({
                        url: "",
                        width: dialogFeatures.width,
                        height: dialogFeatures.height,
                        onCallback: onDialogComplete,
                        onReady: onOpenLegacyDialog
                    });

                } else {
                    dialogURL += '&allcontentgroups=' + allContentGroups;

                    ed.windowManager.open({
                        url: dialogURL,
                        width: dialogFeatures.width,
                        height: dialogFeatures.height,
                        onCallback: onDialogComplete
                    });
                }
            });

            // Removed keyboard shortcut due to conflict with Gecko browsers bookmark dialog.
            //ed.addShortcut("ctrl+shift+d", "epidynamiccontent.desc", "mceEPiDynamicContent");

            /**
            * Get run when the editor is initialized or changes state (full size editor for instance).
            *
            * @param {tinymce.Editor} ed Editor instance that the plugin is initialized in.
            */
            var pluginInit = function (ed) {
                var mouseDownEvent = tinymce.dom.Event.add(tinymce.DOM.doc, "mousedown", self._handleButtonsClick, self),
                    clickEventHandle = tinymce.dom.Event.add(ed.dom.doc, "click", self._handleButtonsClick, self);

                ed.onRemove.add(function (ed) {
                    tinymce.dom.Event.remove(ed.dom.doc, "click", clickEventHandle);
                    tinymce.dom.Event.remove(tinymce.DOM.doc, "mousedown", mouseDownEvent);
                });

                /**
                * Add a top node change handler to set overall enable/disable state of buttons.
                *
                * @param {tinymce.Editor} ed Editor instance that the plugin is initialized in.
                * @param {Control manager} controlManager Control manager for the node change event.
                * @param {node} currentNode The current node.
                * @param {bool} isSelectionCollapsed If the selection is collapsed or not.
                * @param {options} options Additional options like if it's the node change that is run on initialization for the editor.
                */
                ed.onNodeChange.add(function (ed, controlManager, currentNode, isSelectionCollapsed, options) {
                    // Listening to onNodeChange very early (addToTop) since we're fiddling with
                    // other plugin states and possibly changing the current selection.

                    var selection = ed.selection;
                    var dynamicContent = null;

                    if (selection.isCollapsed()) {
                        // When the selection is collapsed it seems start and end of selection often differ, 
                        // but the start seems more reliable
                        dynamicContent = self._getParentContentBlock(selection.getNode());
                    } else {
                        // Check if start or end of current selection is inside a dynamic content block.
                        dynamicContent = self._getParentContentBlock(selection.getStart()) || self._getParentContentBlock(selection.getEnd());
                    }

                    if (dynamicContent) {
                        // Disable all other buttons
                        self._updateCommandState(false);

                        // Enable dynamic content button
                        self._showButton(ed, controlManager, true, true);
                    } else {
                        // Outside dynamic content, enable all other buttons again
                        self._updateCommandState(true);

                        // co = Is the selection collapsed
                        // Enable dynamic content button if the current selection is collapsed.
                        self._showButton(ed, controlManager, isSelectionCollapsed, false);
                    }
                });
            };

            // If the editors onInit event has already been raised, just run the method. Otherwise attach.
            if (self._onInitCalled) {
                pluginInit(ed);
            } else {
                ed.onInit.add(pluginInit);
            }
        },

        /**
        * Set enabled and active state of the dynamic content button
        *
        * @param {tinymce.Editor} ed Editor instance that the plugin is initialized in.
        * @param {Control manager} controlManager Control manager.
        * @param {bool} enabled If true, the button is enabled; otherwise disabled.
        * @param {bool} active If true, the button is set active; otherwise inactive.
        *
        **/
        _showButton: function (ed, controlManager, enabled, active) {
            var isHidden = ed.dom.isHidden(ed.container);
            controlManager.setDisabled("epidynamiccontent", isHidden || !enabled);
            controlManager.setActive("epidynamiccontent", !isHidden && active);
        },

        /**
        * Handle action buttons in dc header
        *
        * @param {Event} e The event object.
        */
        _handleButtonsClick: function (e) {
            // Left button only, IE never gets here so we can trust that 0 is left button
            if (this.ed.dom.hasClass(e.target, "epi_dc_editBtn") && (e.button === 0)) {
                this._hidePreview(e);
                tinyMCE.execCommand('mceEPiDynamicContent');
                return tinymce.dom.Event.cancel(e);
            }

            if ($(e.target).is(".epi_dc_previewBtn") && (e.button === 0)) {
                this._showPreview(e);
                return tinymce.dom.Event.cancel(e);
            }

            this._hidePreview(e);
        },

        /**
        * Returns any dynamic content that is a parent to the given node.
        *
        * @param {Node} node The current node.
        */
        _getParentContentBlock: function (node) {
            return this._getParentNode(node, this._dynamicContentClass);
        },

        /**
        * Convert a dynamic content node to mceNonEditable.
        *
        * @param {Node} node The dymanic content node.
        */
        _convertDCToMceNonEditable: function (node, mceNonEditableClass) {
            var nodeClass = node.attr("class") + " ";
            
            if (nodeClass.indexOf("epi_dc ") === -1 || nodeClass.indexOf(mceNonEditableClass) >= 0) {
                return;
            }            

            // remove contenteditable attribute
            node.attr("contenteditable", null);

            //add mceNoneditable class
            node.attr("class", nodeClass + mceNonEditableClass);
        },

        _url: null, // the url this plugin was initialized with
        _previewedDynamicContent: null, // used to synchronize display of the preview popup
        _previewVisible: false, // whether a preview frame has been created in the parent frame
        _lastSelection: null,

        /**
        * Creates a popup and shows the preview dynamic content frame.
        *
        * @param {evt} node The node or child node to show the preview for.
        */
        _showPreview: function (evt) {
            var node = evt.target;
            if (this._hidePreview(evt)) {
                $(window['epi-dcPreview'].document.documentElement).remove();
            }

            var dynamicContent = $("<div/>", this.ed.contentDocument).append($(node).closest(".epi_dc").clone());
            var dynamicContentHtml = $(dynamicContent).html();
            this._previewedDynamicContent = dynamicContentHtml;

            var self = this;
            setTimeout(function () {
                if (dynamicContentHtml !== self._previewedDynamicContent) {
                    $(dynamicContent).remove();
                    return;
                }

                self._previewVisible = true;
                self._lastSelection = node;

                // create a preview frame next to the dynamic content element in the parent frame
                var iframe = $("iframe", self.ed.container);
                var popupPosition = self._getPositionInParentFrame(node, self.ed.contentWindow, iframe, window);

                var dialogWidth = self.ed.settings.editorwidth || self.ed.contentAreaContainer.clientWidth + "px";

                var frame = self._createPopupIframe(popupPosition, "epi-dcPreview", dialogWidth,
                /*buttons:*/[{ onclick: function () { self._openEditDialog(self.ed); self._hidePreview(); }, text: self.ed.translate("epidynamiccontent.edit") },
                             { onclick: function () { self._hidePreview(); }, text: self.ed.translate("epidynamiccontent.close") }
                ]);

                var previewUrl = self._getPreviewUrl();
                var previewData = { "DynamicContent": dynamicContentHtml }; // a little hack to retrieve "outerHTML"
                self._postFrameTo(frame, previewUrl, previewData);
                $(dynamicContent).remove();

                $(window).bind("resize.dynamicContent",
                    function (e) {
                        var position = self._getPositionInParentFrame(node, self.ed.contentWindow, iframe, window);
                        var previewBorder = $("#epi-dcPreview");
                        previewBorder.css(position);
                    }
                );

                // add some text below the preview
                //TODO: Reimplement this if possible
                //$("#dcPreviewDescription").html($(dcSpan).html().replace(/[{}]/g, ""));

            }, 250);
        },

        /**
        * Gets an url to the preview page that depends on new page or existing page.
        */
        _getPreviewUrl: function () {
            var url = "Editor/Dialogs/DynamicContentPreview.aspx";
            var ctx = jQuery.extend({ "content_css": this.ed.settings.content_css }, this.ed.settings.epi_page_context);
            $(document).trigger("epi.loading.page_context", ctx);

            return EPi.ResolveUrlFromUI(url + "?" + jQuery.param(ctx));
        },

        /**
        * Opens the edit dialog for the dynamic content when a user has clicked on the inline edit button.
        */
        _openEditDialog: function () {
            this.ed.focus();
            var dynamicContent = this._getParentContentBlock(this._lastSelection);
            this.ed.selection.select(dynamicContent);
            tinyMCE.execCommand('mceEPiDynamicContent');
        },

        /**
        * Removes the dynamic content preview frame.
        */
        _hidePreview: function (evt) {
            this._previewedDynamicContent = null;
            if ((evt && this._isChildOfDCPreview(evt.target)) || !this._previewVisible) {
                return false;
            }
            this._previewVisible = false;
            this._lastSelection = null;
            $("#epi-dcPreview").hide();

            $(window).unbind("resize.dynamicContent");

            return true;
        },

        /**
        * Gets the absolute position in the parent farme next to an element inside the editor frame
        */
        _getPositionInParentFrame: function (element, childWindow, childIframe, parentWindow) {
            // calculate popup position relative to element, frame position and scroll in both frames
            var framePosition = $(childIframe).offset();
            var dcPosition = $(element).position();
            var windowScroll = { y: $(parentWindow).scrollTop(), x: $(parentWindow).scrollLeft() };
            var frameScroll = { y: Math.max($(childWindow.document.body).scrollTop(), $(childWindow.document.documentElement).scrollTop()), x: $(childWindow.document.body).scrollLeft() };
            var position = {
                top: framePosition.top + dcPosition.top - windowScroll.y - frameScroll.y,
                left: framePosition.left + dcPosition.left + Math.min($(element).width() + 10, $(childIframe).width()) - windowScroll.x - frameScroll.x
            };

            // deal with browser quirks
            if (windowScroll.y > 0 && (tinymce.isGecko || tinymce.isWebKit)) {
                position.top += frameScroll.y;
            }
            if (tinymce.isIE) {
                position.top += windowScroll.y;
            }

            // avoid disappearing off-screen
            var $parentWindow = $(parentWindow);
            var lowerBound = position.top + 300;
            var windowBottomY = windowScroll.y + $parentWindow.height();
            if (lowerBound > windowBottomY) {
                position.top = Math.max(windowScroll.y, position.top - lowerBound + windowBottomY);
            }

            var dialogWidth = this.ed.settings.editorwidth ? this.ed.settings.editorwidth : this.ed.settings.width;
            lowerBound = position.left + parseInt(dialogWidth, 10) + 24; //24 = dialog padding
            var windowRightX = windowScroll.x + $parentWindow.width();
            if (lowerBound > windowRightX) {
                position.left = Math.max(windowScroll.x, position.left - lowerBound + windowRightX);
            }

            return position;
        },

        /**
        * Creates a popup iframe
        */
        _createPopupIframe: function (popupPosition, frameName, width, buttons) {
            var self = this;
            var previewBorder = $("#" + frameName).show();

            if (previewBorder.length === 0) {
                previewBorder = $("<div id='" + frameName + "' class='epi-dcPreviewBorder'><iframe frameborder='0' style='height:300px;' class='episystemiframe' name='" + frameName + "' src=''></iframe><div id='epi-dcPreviewButtons'></div><div id='epi-dcPreviewDescription'></div></div>")
                    .appendTo(window.document.body);
                $(window.document.body).click(function (evt) { self._hidePreview(evt); });
            }
            previewBorder.css({ position: "absolute", top: popupPosition.top, left: popupPosition.left, width: width })
                .children("iframe").css({ height: "250px", width: "100%" });

            if (buttons) {
                $("#epi-dcPreviewButtons").html("");
                for (var i in buttons) {
                    $("<span class='epi-cmsButton'><input type='button' value='" + buttons[i].text + "'/></span>")
                        .appendTo("#epi-dcPreviewButtons")
                        .click(buttons[i].onclick);
                }
            }

            // post the dynamic content to be rendered by the server
            var frame = window[frameName];
            return frame;
        },

        /**
        * Verifies the given dom node is a child of DC preview container or not
        *
        * @param {target} a dom node that needed to verifies.
        */
        _isChildOfDCPreview: function (/*DOM*/target) {
            var targetObject = $(target),
                dcPreviewContainerClass = ".epi-dcPreviewBorder";

            return targetObject.is(dcPreviewContainerClass) || targetObject.parents().is(dcPreviewContainerClass);
        },

        /**
        * Writes some content to a frame and performs a http post
        */
        _postFrameTo: function (frame, url, data) {
            var formString = '<html xmlns="http://www.w3.org/1999/xhtml" style="height:100%;background:#fff url(' + EPi.ResolveUrlFromUtil("../App_Themes/Default/Images/General/AjaxLoader.gif") + ') no-repeat 50% 50%"><head><title></title></head><body>';
            formString += '<form action="' + url + '" method="post">';
            var key;
            for (key in data) {
                formString += '<input name="' + key + '" id="' + key + '" type="hidden" />';
            }
            formString += '</form></body></html>';

            frame.document.write(formString);

            for (key in data) {
                frame.document.getElementById(key).value = data[key];
            }
            frame.document.forms[0].submit();
        },

        /**
        * Returns information about the plugin as a name/value array.
        *
        * @return {Object} Name/value array containing information about the plugin.
        */
        getInfo: function () {
            return {
                longname: 'Dynamic content plugin',
                author: 'EPiServer AB',
                authorurl: 'http://www.episerver.com',
                infourl: 'http://www.episerver.com',
                version: 1.1
            };
        }
    });

    // Register plugin
    tinymce.PluginManager.add('epidynamiccontent', tinymce.plugins.epidynamiccontent);
} (tinymce, epiJQuery));
