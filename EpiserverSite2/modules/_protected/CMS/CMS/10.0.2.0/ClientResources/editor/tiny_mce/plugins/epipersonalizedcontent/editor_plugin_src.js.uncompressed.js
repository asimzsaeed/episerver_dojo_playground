(function (tinymce, $) {
    tinymce.create('tinymce.plugins.epipersonalizedcontent', {
        _onInitCalled: false, // A flag to signal if the editors onInit event has occured

        // Clipboard and Dnd states
        _pcDragging: false,
        _pcInClipboard: false,

        /**
        * Initializes the plugin, this will be executed after the plugin has been created.
        * This call is done before the editor instance has finished it's initialization so use the onInit event
        * of the editor instance to intercept that event.
        *
        * @param {tinymce.Editor} ed Editor instance that the plugin is initialized in.
        * @param {string} url Absolute URL to where the plugin is located.
        */
        init: function (ed, url) {
            var self = this;
            if (typeof epiContentBlockUtilities == "undefined") {
                var scriptUrl = tinymce.baseURI.toAbsolute("plugins/epipersonalizedcontent/epicontentblockutilities.js");
                tinymce.ScriptLoader.load(scriptUrl, function () {
                    this._init(ed, url);
                }, this);

                tinymce.ScriptLoader.loadQueue();
            }
            else {
                this._init(ed, url);
            }

            // Register button - must be done in standard init since it seems to be to late in callback
            ed.addButton('epipersonalizedcontent', {
                title: 'epipersonalizedcontent.epipersonalizedcontent_desc',
                cmd: 'epipersonalizedcontent',
                "class": "mce_epipersonalizedcontent"
            });

            // Flagging that onInit has been executed since _init is executed async and can be called after the editors onInit has been raised.
            ed.onInit.add(function () {
                self._onInitCalled = true;
            });

            ed.onPreInit.addToTop(function () {
                var mceNonEditableClass = tinymce.trim(ed.getParam("noneditable_noneditable_class", "mceNonEditable")),
                    mceEditableClass = tinymce.trim(ed.getParam("noneditable_editable_class", "mceEditable"));

                // Remove contenteditable attribute generated by DynamicFragmentFactory and add mceNonEditable class.
                ed.parser.addAttributeFilter('class', function (nodes) {
                    var i = nodes.length, className, node;

                    while (i--) {
                        self._convertPCToMceNonEditable(nodes[i], mceNonEditableClass, mceEditableClass);
                    }
                });
            });
        },

        /**
        * The real initialization triggered by a callback. Adds command and event handlers.
        *
        * @param {tinymce.Editor} ed Editor instance that the plugin is initialized in.
        * @param {string} url Absolute URL to where the plugin is located.
        */
        _init: function (ed, url) {
            //We extend this plug.in with methods that are common for both personalized content and dynamic content (defined in epicontentblockutilities.js).
            $.extend(this, epiContentBlockUtilities);
            var self = this;
            self._personalizedContentHeaderClass = ed.getParam("epipersonalizedcontent_headercssclass", "epi_pc_h");
            self._personalizedContentFooterClass = ed.getParam("epipersonalizedcontent_footercssclass", "epi_pc_f");
            self._personalizedContentClass = ed.getParam("epipersonalizedcontent_cssclass", "epi_pc");
            self._personalizedContentHolderClass = ed.getParam("epipersonalizedcontent_holdercssclass", "epi_pc_content");
            self.ed = ed;
            self._disabled = false; // Initially no controls are disabled.
            self._enabledControls = ed.getParam("epipersonalizedcontent_enabledcontrols", "");

            ed.addCommand('epipersonalizedcontent', function () {

                if (!self._validateAndCorrectSelection()) {
                    ed.windowManager.alert(ed.translate('epipersonalizedcontent.invalidselectionwarning'));
                    return;
                }

                var pc = self._getParentNode(self._getCommonAncestor(), self._personalizedContentClass);

                var onDialogComplete = function (returnData, onCompleteArgs) {

                    var innerContent,
                        html,
                        contentNode;

                    if (ed.windowManager.bookmark) {
                        ed.selection.moveToBookmark(ed.windowManager.bookmark);
                    }

                    if (!returnData) {
                        return;
                    }

                    // Insert trailing element if necessary.
                    // If selection is the last block element, after delete selection, mceInsertContent will move the caret to the previous block.
                    // Now, if the previous block is also a pc, the one to be created will be a nested one.
                    // epiTrailing plugin actually does add a bogus p but it's too late when the command is done. If we add the trailing here, epiTrailing will just do nothing.
                    var body = ed.getBody(),
                        last = body && body.lastChild;
                    if (ed.selection.getNode() === last) {
                        body.appendChild(ed.dom.create('p', null, '<br _mce_bogus="1" />'));
                    }

                    if (returnData.removePersonalization) {
                        if (pc) {
                            contentNode = ed.dom.select("." + self._personalizedContentHolderClass, pc)[0];
                            innerContent = contentNode.innerHTML;

                            ed.dom.remove(pc);
                            ed.execCommand('mceInsertContent', false, innerContent);
                        }
                    }
                    else if (pc) {
                        contentNode = ed.dom.select("." + self._personalizedContentHolderClass, pc);
                        innerContent = $(contentNode).html();
                        html = returnData.replace("[personalizedContentPlaceHolder]", innerContent);
                        //Update existing personalized content block

                        ed.dom.remove(pc);
                        ed.execCommand('mceInsertContent', false, html);
                    }
                    else {
                        //Create new personalized content block
                        innerContent = ed.selection.getContent();
                        if (innerContent === "") {
                            innerContent = '<p><br mce_bogus="1" /></p>';
                        }
                        html = returnData.replace("[personalizedContentPlaceHolder]", innerContent);

                        // In Webkit, delete selection still keep the enclosing "block" element (div, p, etc.) if there exists. That would consequently put the created pc inside that element.
                        // If we for example personalized a content block fragment, the non-editability would be broken.
                        // Therefore, take an early hand to remove selection if it entirely encloses one block element. 
                        if (ed.selection.getStart() === ed.selection.getEnd()) {
                            ed.dom.remove(ed.selection.getNode());
                        }
                        ed.execCommand('mceInsertContent', false, html);
                    }

                    self._onContentChanged();
                };

                var dialogFeatures = { width: 600, height: 450 };
                var dialogURL = EPi.ResolveUrlFromUI('Editor/Dialogs/PersonalizedContent.aspx');

                var parameters = {
                    allContentGroups: self._getAllContentGroups()
                };

                if (pc) {
                    parameters.groups = ed.dom.getAttrib(pc, "data-groups", "");
                    parameters.contentGroup = ed.dom.getAttrib(pc, "data-contentgroup", "");
                } else if (ed.selection.isCollapsed()) {
                    // We have no personalized content selected and no active selection. The editor 
                    // has likely been activated by a click on the PC button and the selection lost.
                    return;
                }

                ed.windowManager.open({
                    url: dialogURL + "?" + $.param(parameters),
                    width: dialogFeatures.width,
                    height: dialogFeatures.height,
                    onCallback: onDialogComplete
                });

            });

            /**
            * Adds event handlers.
            *
            * @param {tinymce.Editor} ed Editor instance that the plugin is initialized in.
            */
            var pluginInit = function (ed) {
                // Prevent drag & drop of content into personalized content.
                // Note: This makes use of jQuery to overcome differences in native event object.

                var clickEventHandle = tinymce.dom.Event.add(ed.dom.doc, "click", function (e) { self._handleButtonsClick(e); });

                self._showButton(ed, ed.controlManager, false, false);

                ed.onRemove.add(function (ed) {
                    tinymce.dom.Event.remove(ed.dom.doc, clickEventHandle);
                });

                /**
                * Add a node change handler, selects the button in the UI when the selection is not collapsed
                * or inside an existing personalized content block.
                *
                * @param {tinymce.Editor} ed Editor instance that the plugin is initialized in.
                * @param {Control manager} controlManager Control manager for the node change event.
                * @param {node} node The current node.
                * @param {bool} collapsed If the selection is collapsed or not.
                * @param {options} options Additional options like if it's the node change that is run on initialization for the editor.
                */
                ed.onNodeChange.add(function (ed, controlManager, node, collapsed, options) {

                    // Make it run lastish...
                    setTimeout(function () {
                        var inPC = !!self._getParentNode(node, self._personalizedContentClass),
                            inPCContent = !!self._getParentNode(node, self._personalizedContentHolderClass);

                        // Disable locked commands if we are in a PC header
                        if (inPC && !inPCContent) {
                            self._updateCommandState(false);
                        }

                        // PC button is active when we are inside a pc block.
                        // It is enabled when selection is not collapsed (create) or we are inside a pc (edit)
                        self._showButton(ed, controlManager, !collapsed || inPC, inPC);
                    }, 0);

                });

                // Enable early so the plugins can disable again if needed
                ed.onNodeChange.addToTop(function (ed, controlManager, node, collapsed, options) {

                    var inPC = !!self._getParentNode(node, self._personalizedContentClass),
                        inPCContent = !!self._getParentNode(node, self._personalizedContentHolderClass);

                    // Enable locked commands if we are NOT inside a PC or inside PC content holder
                    if (!inPC || inPCContent) {
                        self._updateCommandState(true);
                    }
                });

                ed.dom.bind(ed.getBody(), "dragstart", function (e) {
                    self._pcDragging = self._selectionContainsPC();
                });

                ed.dom.bind(ed.getBody(), "dragend", function (e) {
                    self._pcDragging = false;
                });

                ed.dom.bind(ed.getBody(), "cut", function (e) {
                    self._pcInClipboard = self._selectionContainsPC();
                });

                ed.dom.bind(ed.getBody(), "copy", function (e) {
                    self._pcInClipboard = self._selectionContainsPC();
                });

                ed.dom.bind(ed.getBody(), "drop", function (e) {
                    self._preventNestedPC(e);
                });

                ed.dom.bind(ed.getBody(), "paste", function (e) {
                    self._preventNestedPC(e);
                });
            };

            // If the editors onInit event has already been raised, just run the method. Otherwise attach.
            if (self._onInitCalled) {
                pluginInit(ed);
            } else {
                ed.onInit.add(pluginInit);
            }
        },

        /**
        * Prevent nested PC on drop/paste
        */
        _preventNestedPC: function (event) {
            var aboutToInsertPC = (event.type === "drop") ? this._pcDragging : ((event.type === "paste") ? this._pcInClipboard : false),
                target = event.srcElement || event.originalTarget;

            //if it is editor's body
            if (target === this.ed.getBody()) {
                //target can be the caret node if selection is collapsed
                target = this.ed.selection.isCollapsed() ? this.ed.selection.getNode() : target;
            }

            if (aboutToInsertPC && !!this._getParentNode(target, this._personalizedContentHolderClass)) {
                this.ed.dom.events.cancel(event);
                return false;
            }
        },

        /**
        * Set enabled and active state of the personalized content button
        *
        * @param {tinymce.Editor} ed Editor instance that the plugin is initialized in.
        * @param {Control manager} controlManager Control manager.
        * @param {bool} enabled If true, the button is enabled; otherwise disabled.
        * @param {bool} active If true, the button is set active; otherwise inactive.
        *
        **/
        _showButton: function (ed, controlManager, enabled, active) {
            if (!ed.destroyed) {
                var isHidden = ed.dom.isHidden(ed.container);
                controlManager.setDisabled("epipersonalizedcontent", isHidden || !enabled);
                controlManager.setActive("epipersonalizedcontent", !isHidden && active);
            }
        },

        /**
        * Handle action buttons in dc header
        *
        * @param {Event} e The event object.
        */
        _handleButtonsClick: function (e) {
            //Left button only, IE never gets here so we can trust that 0 is left button
            if (this.ed.dom.hasClass(e.target, "epi_pc_editBtn") && (e.button === 0)) {
                tinyMCE.execCommand('epipersonalizedcontent');
                return tinymce.dom.Event.cancel(e);
            }
        },

        /**
        * Validates that the current selection does not contain parts of a personalized content.
        */
        _validateAndCorrectSelection: function () {
            var parentNode = this._getCommonAncestor();
            var startNode = this.ed.selection.getStart();
            var endNode = this.ed.selection.getEnd();
            var nodeToPersonalize, container;

            if (startNode !== endNode) {
                //We have a selection where the start or end is inside a table or list but the selection goes outside of the list or table
                container = this._getNotPersonalizableContainer(startNode, parentNode);
                if (container) {
                    nodeToPersonalize = this._getPersonalizableParent(container);
                } else {
                    container = this._getNotPersonalizableContainer(endNode, parentNode);
                    if (container) {
                        nodeToPersonalize = this._getPersonalizableParent(container);
                    }
                }
            } else {
                nodeToPersonalize = this._getPersonalizableParent(parentNode);
            }

            if (nodeToPersonalize) {
                //We have found a node that is personalizable
                this.ed.selection.select(nodeToPersonalize);
                if (!this.ed.dom.hasClass(nodeToPersonalize, this._personalizedContentClass)) {
                    var personalizedContents = tinyMCE.activeEditor.dom.select("div." + this._personalizedContentClass, nodeToPersonalize);
                    if (personalizedContents.length > 0) {
                        return false;
                    }
                }
            }
            else {
                //We have not found a parent node that is a block element. This is probably the body element.
                return this.ed.selection.getContent().match(this._personalizedContentClass) === null;
            }
            return true;
        },

        _getPersonalizableParent: function (node) {
            var self = this;
            return this.ed.dom.getParent(node, function (parent) {

                if (node.nodeName === "LI") {
                    return parent.nodeName === "UL" || parent.nodeName === "OL";
                } else if (node.nodeName === "TR" || node.nodeName === "TD" || node.nodeName === "TH" ||
                    node.nodeName === "TBODY" || node.nodeName === "THEAD" || node.nodeName === "TFOOT") {
                    return parent.nodeName === "TABLE";
                } else if (node.nodeName === "DT" || node.nodeName === "DD") {
                    return parent.nodeName === "DL";
                }
                return self.ed.dom.isBlock(parent);
            });
        },

        _isNotPersonalizableNode: function (node) {
            return node.nodeName === "TD" || node.nodeName === "TR" || node.nodeName === "TH" ||
                node.nodeName === "TBODY" || node.nodeName === "THEAD" || node.nodeName === "TFOOT" ||
                node.nodeName === "LI" || node.nodeName === "DT" || node.nodeName === "DD";
        },

        _getNotPersonalizableContainer: function (node, root) {
            var self = this;

            return this.ed.dom.getParent(node, function (parent) {
                return self._isNotPersonalizableNode(parent);
            }, root);
        },

        /**
        * Check if selection contains any pc block
        */
        _selectionContainsPC: function () {
            var pcMatchRule = new RegExp('<div.*' + this._personalizedContentClass
                + '.*>(\\n|.)*<div.*' + this._personalizedContentHeaderClass
                + '.*>(\\n|.)*<div.*' + this._personalizedContentHolderClass
                + '.*>(\\n|.)*<div.*' + this._personalizedContentFooterClass
                + '.*>');

            return this.ed.dom.hasClass(this.ed.selection.getNode(), this._personalizedContentClass) || this.ed.selection.getContent().match(pcMatchRule);
        },

        /**
        * Gets the common ancestor for the current selection.
        */
        _getCommonAncestor: function () {
            //sometime tinymce return incorrect common ancestor, we should return the correct value if we exactly know
            if (this.ed.selection.getStart() == this.ed.selection.getEnd()) {
                return this.ed.selection.getStart();
            }

            var commonAncestor = this.ed.selection.getRng(true).commonAncestorContainer;
            if (!commonAncestor || commonAncestor.tagName == "HTML") {
                return this.ed.getBody();
            }
            return commonAncestor;
        },

        /**
        * Convert a personalized content node to mceNonEditable.
        *
        * @param {Node} node The dc node.
        */
        _convertPCToMceNonEditable: function (node, mceNonEditableClass, mceEditableClass) {
            var nodeClass = node.attr("class") + " ";

            if (nodeClass.indexOf("epi_pc ") !== -1 && nodeClass.indexOf(mceNonEditableClass) !== 0) {
                //add mceNoneditable class
                node.attr("class", nodeClass + mceNonEditableClass);
            } else if (nodeClass.indexOf("epi_pc_h ") !== -1) {
                // remove contenteditable attribute
                node.attr("contenteditable", null);
            } else if (nodeClass.indexOf("epi_pc_f ") !== -1) {
                // remove contenteditable attribute
                node.attr("contenteditable", null);
            } else if (nodeClass.indexOf("epi_pc_content ") !== -1 && nodeClass.indexOf(mceNonEditableClass) !== 0) {
                //add mceNoneditable class
                node.attr("class", nodeClass + mceEditableClass);
            }
        },

        /**
        * Returns information about the plugin as a name/value array.
        * The current keys are longname, author, authorurl, infourl and version.
        *
        * @return {Object} Name/value array containing information about the plugin.
        */
        getInfo: function () {
            return {
                longname: 'EPiServer CMS Personalized Content Plug-in',
                author: 'EPiServer AB',
                authorurl: 'http://www.episerver.com',
                infourl: 'http://www.episerver.com',
                version: "1.0"
            };
        }
    });

    // Register plugin
    tinymce.PluginManager.add('epipersonalizedcontent', tinymce.plugins.epipersonalizedcontent);
}(tinymce, epiJQuery));
